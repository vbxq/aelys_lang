// Opcodes 0-121. There's a lot of them because we have specialized
// variants for common patterns (AddII = int+int, AddFF = float+float, etc).
// Keeps the interpreter fast by avoiding type checks in hot paths.

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum OpCode {
    Move = 0,
    LoadI,
    LoadK,
    LoadNull,
    LoadBool,
    Add,  // generic add, does type dispatch
    Sub,
    Mul,
    Div,
    Mod,
    Neg,
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,
    Not,
    Jump,
    JumpIf,
    JumpIfNot,
    Call,
    Return,
    Return0,
    GetGlobal,
    SetGlobal,
    EnterNoGc,
    ExitNoGc,
    Alloc,
    Free,
    LoadMem,
    LoadMemI,
    StoreMem,
    StoreMemI,
    Print,
    MakeClosure,
    GetUpval,
    SetUpval,
    CloseUpvals,
    IncGlobalI,
    ForLoopI,
    ForLoopIInc,
    AddI,
    SubI,
    LtImm,
    LeImm,
    GtImm,
    GeImm,
    WhileLoopLt,
    AddII,
    SubII,
    MulII,
    DivII,
    ModII,
    AddFF,
    SubFF,
    MulFF,
    DivFF,
    ModFF,
    LtII,
    LeII,
    GtII,
    GeII,
    EqII,
    NeII,
    LtFF,
    LeFF,
    GtFF,
    GeFF,
    EqFF,
    NeFF,
    LtIImm,
    LeIImm,
    GtIImm,
    GeIImm,
    GetGlobalIdx,
    SetGlobalIdx,
    CallGlobal,
    CallGlobalMono,
    CallCached,
    CallUpval,
    TailCallUpval,
    AddIIG,
    SubIIG,
    MulIIG,
    DivIIG,
    ModIIG,
    AddFFG,
    SubFFG,
    MulFFG,
    DivFFG,
    ModFFG,
    LtIIG,
    LeIIG,
    GtIIG,
    GeIIG,
    EqIIG,
    NeIIG,
    LtFFG,
    LeFFG,
    GtFFG,
    GeFFG,
    EqFFG,
    NeFFG,
    CallGlobalNative,
    Shl,
    Shr,
    BitAnd,
    BitOr,
    BitXor,
    BitNot,
    ShlII,
    ShrII,
    AndII,
    OrII,
    XorII,
    NotI,
    ShlIImm,
    ShrIImm,
    AndIImm,
    OrIImm,
    XorIImm,
}

impl OpCode {
    pub fn from_u8(byte: u8) -> Option<Self> {
        if byte <= Self::XorIImm as u8 {
            Some(unsafe { std::mem::transmute(byte) })
        } else {
            None
        }
    }
}
