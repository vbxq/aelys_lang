needs std.net as net
needs std.string as str
needs std.convert as convert
needs utils

pub fn parse_method(request_line: string) -> string {
    let trimmed = str.trim(request_line)
    let space_idx = str.find(trimmed, " ")

    if space_idx > 0 {
        return str.substr(trimmed, 0, space_idx)
    }

    return "GET"
}

pub fn parse_path(request_line: string) -> string {
    let trimmed = str.trim(request_line)
    let first_space = str.find(trimmed, " ")

    if first_space < 0 {
        return "/"
    }

    let after_method = str.substr(trimmed, first_space + 1, str.len(trimmed) - first_space - 1)
    let second_space = str.find(after_method, " ")

    if second_space > 0 {
        return str.substr(after_method, 0, second_space)
    }

    return str.trim(after_method)
}

fn parse_version(request_line: string) -> string {
    let trimmed = str.trim(request_line)

    let mut last_space = -1
    let mut i = 0
    while i < str.len(trimmed) {
        let char = str.substr(trimmed, i, 1)
        if char == " " {
            last_space = i
        }
        i = i + 1
    }

    if last_space > 0 {
        return str.trim(str.substr(trimmed, last_space + 1, str.len(trimmed) - last_space - 1))
    }

    return "HTTP/1.1"
}

pub fn parse_headers(client: int) {
    let mut header_data = ""

    while true {
        let line = net.recv_line(client)
        let trimmed = str.trim(line)

        if str.len(trimmed) == 0 {
            break
        }

        header_data = header_data + line + "\n"
    }

    return fn(name: string) -> string {
        let search = str.to_lower(name) + ":"
        let mut lines = str.split(header_data, "\n")

        let mut i = 0
        while i < 100 {
            let line_end = str.find(lines, "\n")
            if line_end < 0 {
                break
            }

            let line = str.substr(lines, 0, line_end)
            let lower_line = str.to_lower(line)

            if str.starts_with(lower_line, search) {
                let value_start = str.find(line, ":") + 1
                return str.trim(str.substr(line, value_start, str.len(line) - value_start))
            }

            lines = str.substr(lines, line_end + 1, str.len(lines) - line_end - 1)
            i = i + 1
        }

        return ""
    }
}

pub fn read_body(client: int, headers) -> string {
    let content_length_str = headers("Content-Length")

    if str.len(content_length_str) == 0 {
        return ""
    }

    let content_length = convert.parse_int(content_length_str)
    if content_length == null or content_length <= 0 {
        return ""
    }

    return net.recv_bytes(client, content_length)
}

pub fn send_response(client: int, status: int, content_type: string, body: string) {
    let mut response = "HTTP/1.1 " + convert.to_string(status) + " " + utils.status_text(status) + "\r\n"

    response = response + "Content-Type: " + content_type + "\r\n"
    response = response + "Content-Length: " + convert.to_string(str.len(body)) + "\r\n"
    response = response + "Connection: close\r\n"
    response = response + "Server: Aelys-HTTP/0.1.0\r\n"

    response = response + "\r\n"

    response = response + body

    net.send(client, response)
}

pub fn send_json(client: int, status: int, json_body: string) {
    send_response(client, status, "application/json; charset=utf-8", json_body)
}

pub fn send_text(client: int, status: int, text_body: string) {
    send_response(client, status, "text/plain; charset=utf-8", text_body)
}

pub fn send_html(client: int, status: int, html_body: string) {
    send_response(client, status, "text/html; charset=utf-8", html_body)
}

pub fn send_error(client: int, status: int, message: string) {
    let mut html = "<!DOCTYPE html>\n"
    html = html + "<html>\n<head>\n"
    html = html + "<title>" + convert.to_string(status) + " " + utils.status_text(status) + "</title>\n"
    html = html + "<style>body{{font-family:sans-serif;max-width:600px;margin:100px auto;text-align:center}}</style>\n"
    html = html + "</head>\n<body>\n"
    html = html + "<h1>" + convert.to_string(status) + " " + utils.status_text(status) + "</h1>\n"
    html = html + "<p>" + message + "</p>\n"
    html = html + "<hr><small>Aelys HTTP Server</small>\n"
    html = html + "</body>\n</html>"

    send_html(client, status, html)
}
